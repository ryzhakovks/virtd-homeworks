
# Домашнее задание к занятию 3. «Введение. Экосистема. Архитектура. Жизненный цикл Docker-контейнера»

## Как сдавать задания

Обязательны к выполнению задачи без звёздочки. Их нужно выполнить, чтобы получить зачёт и диплом о профессиональной переподготовке.

Задачи со звёздочкой (*) — дополнительные задачи и/или задачи повышенной сложности. Их выполнять не обязательно, но они помогут вам глубже понять тему.

Домашнее задание выполните в файле readme.md в GitHub-репозитории. В личном кабинете отправьте на проверку ссылку на .md-файл в вашем репозитории.

Любые вопросы по решению задач задавайте в чате учебной группы.

---


## Важно

Перед отправкой работы на проверку удаляйте неиспользуемые ресурсы.
Это нужно, чтобы не расходовать средства, полученные в результате использования промокода.

Подробные рекомендации [здесь](https://github.com/netology-code/virt-homeworks/blob/virt-11/r/README.md).

---

## Задача 1

Сценарий выполнения задачи:

- создайте свой репозиторий на https://hub.docker.com;
- выберите любой образ, который содержит веб-сервер Nginx;
- создайте свой fork образа;
- реализуйте функциональность:
запуск веб-сервера в фоне с индекс-страницей, содержащей HTML-код ниже:
```
<html>
<head>
Hey, Netology
</head>
<body>
<h1>I’m DevOps Engineer!</h1>
</body>
</html>
```

Опубликуйте созданный fork в своём репозитории и предоставьте ответ в виде ссылки на https://hub.docker.com/username_repo.
## Решение 
 Скачиваем образ nginx:  
  ```$ docker pull nginx```
 
 Создаем dockerfile:
 ```
 FROM nginx
 RUN echo '<html><head>Hey, Netology</head><body><h1>I am DevOps Engineer!</h1></body></html>' > /usr/share/nginx/html/index.html
 ```
 Делаем fork образа:  
 ```docker build -f DOCKERFILE -t ryzhakovks/devsys25:1 .```

 Пушим образ в репозиторий на hub.docker.com:  
```$ docker push ryzhakovks/devsys25:1```

 [Ссылка на образ](https://hub.docker.com/layers/ryzhakovks/devsys25/1/images/sha256-bb4cf0951072a82de120e822b39f0c21b8a561b029bb59429d4915250578a6c0?context=repo)
 
 Запускаем контейнер с пробросом на 8080 порт хоста:  
```$ docker run -d -p 8080:80 ryzhakovks/devsys25:1```



## Задача 2

Посмотрите на сценарий ниже и ответьте на вопрос:
«Подходит ли в этом сценарии использование Docker-контейнеров или лучше подойдёт виртуальная машина, физическая машина? Может быть, возможны разные варианты?»

Детально опишите и обоснуйте свой выбор.

--

Сценарий+Решение:

- высоконагруженное монолитное Java веб-приложение; Считаю что физическая машина выдленная только под это приложения, докер испольщзовать не нужно чтоб получить все ресурсы ПК
- Nodejs веб-приложение; Докер, для исключения проблем с зависомстью и утсновки на другие сервера 
- мобильное приложение c версиями для Android и iOS; Докер, для исключения проблем с зависомстью и утсновки на другие сервера 
- шина данных на базе Apache Kafka; Есть готовы образы докера, необходима клстерезация 
- Elasticsearch кластер для реализации логирования продуктивного веб-приложения - три ноды elasticsearch, два logstash и две ноды kibana;
> Docker, Elasticsearch доступен для установки как образ docker, проще удалять логи, удобнее при кластеризации - меньше времени на запуск контейнеров.
- Мониторинг-стек на базе Prometheus и Grafana;
> Docker. Есть готовые образы, приложения не хранят данные, что удобно при контейниризации, удобно масштабировать и быстро разворачивать.
- MongoDB, как основное хранилище данных для java-приложения;
> Физическая машина как наиболее надежное, отказоустойчивое решение. Либо виртуальный сервер.
- Gitlab сервер для реализации CI/CD процессов и приватный (закрытый) Docker Registry
> Могут быть применены все варианты, в зависимости от наличия соответствующих ресурсов. Но для большей изолированности лучше использовать docker.

## Задача 3

- Запустите первый контейнер из образа ***centos*** c любым тегом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера.
- Запустите второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера.
- Подключитесь к первому контейнеру с помощью ```docker exec``` и создайте текстовый файл любого содержания в ```/data```.
- Добавьте ещё один файл в папку ```/data``` на хостовой машине.
- Подключитесь во второй контейнер и отобразите листинг и содержание файлов в ```/data``` контейнера.

## Решение
- Запускаем первый контейнер из образа ***centos*** c любым тэгом в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера:  
```$ docker run -v /data:/data --name centos -d -t centos```

- Запускаем второй контейнер из образа ***debian*** в фоновом режиме, подключив папку ```/data``` из текущей рабочей директории на хостовой машине в ```/data``` контейнера:  
```$ docker run -v /data:/data --name debian -d -t debian```

- Смотрим запущенные контейнеры:
```
$[root@mmru59a0000 admin]# docker ps
CONTAINER ID   IMAGE                   COMMAND                  CREATED              STATUS              PORTS                                   NAMES
aa7fad2e37bd   debian                  "bash"                   About a minute ago   Up About a minute                                           debian
d2bfadb8e811   centos                  "/bin/bash"              2 minutes ago        Up 2 minutes  
```
- Подключаемся к первому контейнеру с помощью ```docker exec``` и создаем текстовый файл в ```/data```:  
```$ 
[root@mmru59a0000 admin]# docker exec -it centos sh
sh-4.4# echo test > /data/test.txt"```

- Добавляем еще один файл в папку ```/data``` на хостовой машине:
```
[root@mmru59a0000 ~]# touch /data/test2
```

- Подключаемся во второй контейнер и отображаем листинг и содержание файлов в ```/data``` контейнера.  
```
$ [root@mmru59a0000 ~]# docker exec -it debian sh
# ls /data
test.txt  test2

